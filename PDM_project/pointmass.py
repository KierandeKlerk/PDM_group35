import pybullet as p
import time
import numpy as np
import pkg_resources
from tqdm import tqdm
import os

from quadrotor_project.envs.PointMassAviary import PointMassAviary
from quadrotor_project.control.pointmassPID import pointmassPID
from quadrotor_project.planningAlgorithms.occupancyGridTools import generateOccupancyGrid, marginWithDepth
from quadrotor_project.planningAlgorithms.RRT import GridRRTstar2D

from gym_pybullet_drones.utils.enums import DroneModel, Physics
from gym_pybullet_drones.utils.utils import sync


### Settings ###
drone = DroneModel("cf2p")
gui = True # Set to true for visual simulation
record = False # If set to true, will record an mp4; somehow 4 times faster than simulation time
aggregate = True
obstacles = True # Set to true in order to load visual and collision model
simulation_freq_hz = 240
control_freq_hz = 48
duration_sec = 20  # Duration of the simulation

# Obstacle and location settings
obstacleFile = pkg_resources.resource_filename("quadrotor_project", "assets/track1.obj") # Find path to track1.obj file in quadrotor_project/assets
gridPitch = 0.05 # Size of grid cells in occupancy grid
height = 0.8 # in meters 
start_xy = np.array([0.5, 0.5]) # in meters
goal_xy = np.array([2, 5]) # in _meters
dgoal = 5 # Radius around the goal position within which a new node is considered to have 'found' the goal if it is connected to the initial position through a number of edges
dsearch = 10 # Radius around a newly generated node within which is looked for other nodes in order to connect, if not, the newly generated node is dismissed
dcheaper = 15 # Radius within which a new node is searched for that has a cheaper path to the origin
max_iter = 6000 # The maximum amount of iterations reserved for the RRT* algorithm
track_time = 18 # The amount of time the drone has to follow the path generated by RRT*
loadPath = True # If set to true, a path will not be recomputed but instead loaded from the assets folder in our quadrotor_project package
savePath = False # If set to true, the newly computed path will be stored as a npy file in the assets folder in our package

### Initial pose ###

AGGR_PHY_STEPS = int(simulation_freq_hz/control_freq_hz) if aggregate else 1

### Target position calculation through RRT* ###

if not loadPath: # Checking whether to load precomputed path or generate new one
    # Generating occupancy grid
    occupancyGrid, offsets = generateOccupancyGrid(obstacleFile) # Compute the occupancy grid from the 3D mesh file
    print(offsets)
    # Applying RRT*
    start = (start_xy-offsets[:2])/gridPitch
    goal = (goal_xy-offsets[:2])/gridPitch
    grid2D = occupancyGrid[:,:,0] # Take only one slice of the grid (thus making a 2D representation of the grid)
    marginGrid2D = marginWithDepth(grid2D, desiredMarginDepthinMeters=0.2, pitchInMeters=gridPitch) # Add a certain number of margin layers (each layer is on grid layer)
    graph = GridRRTstar2D(start, goal, dgoal, dsearch, dcheaper, grid2D, marginGrid2D, max_iter) # Initializing a 2D RRT* graph class
    starttime = time.time()
    pbar = tqdm(total = max_iter) # Initialize a progress bar
    graph.makemap() # Plot the generated occupancy grid with intial and goal position
    while graph.iterations(): # Loop while the number of iterations is inferior to maxiter
        graph.expand() # Generate a new node
        pbar.update(1) # Update the progress bar
    endtime = time.time()
    pbar.close()
    print("Time elapsed: ", endtime - starttime)
    graph.makemap() # Plot the occupancy map with the calculated path
    
    # Convert path to simulation scale and frame
    path = np.array(graph.smoothpath).T
    path = np.append(path,height/gridPitch*np.ones((len(path),1)), axis = 1) # Append a constant height to the computed 2D path
    path_refit = path*gridPitch+offsets # Scale the path from grid to real coordinates
    if savePath:
        np.save(os.path.join(pkg_resources.resource_filename('quadrotor_project', 'assets/'),"track1.npy"), path_refit) # If savePath is set to True, save the compute path to track1.npy in the assets folder
else: 
    path_refit = np.load(pkg_resources.resource_filename('quadrotor_project',"assets/track1.npy")) # Load the path from the track1.npy file in the assets folder of our package

NUM_WAY_POINTS = int(track_time*control_freq_hz) # Calculate the amount of waypoints we need based on track_time and the chosen control frequency
TARGET_POS = np.zeros((NUM_WAY_POINTS,3)) 
ind = np.round(np.linspace(0, len(path_refit) - 1, NUM_WAY_POINTS)).astype(int) # Choosing indices from the path to make sure the TARGET_POS array is evenly filled up
TARGET_POS = path_refit[ind,:] # Fill up the TARGET_POS array
wp_counter = 0 # Initialize the waypoint counter

### Initiate environment ###
env = PointMassAviary(drone_model=drone,
                      initial_xyz=np.append(start_xy, [height]),
                      initial_rpy=np.array([0,0,0], dtype=float),
                      freq=simulation_freq_hz,
                      aggregate_phy_steps=AGGR_PHY_STEPS,
                      gui=gui,
                      record=record,
                      obstacles=obstacles)

### Initiate PID controller ###
ctrl = pointmassPID(drone_model=drone)

### Run simulation ###
CTRL_EVERY_N_STEPS = int(np.floor(env.SIM_FREQ/control_freq_hz)) # Calculate the fraction of the amount of simulation steps control has to be computed
action = np.zeros(3)
START = time.time()
done = False

for i in range(0, int(duration_sec*env.SIM_FREQ), AGGR_PHY_STEPS): 
    ### Continue simulation if the goal hasn't been reached yet ###
    
    if not done:
        
        ### Step the simulation ###
        state, _ = env.step(action)
        p.resetDebugVisualizerCamera(0.25, 0, -30,state[:3]- [0,0,0]) # turn on to track the drone from behind

        ### Compute control at the desired  frequency
        if i%CTRL_EVERY_N_STEPS == 0:

            ### Compute control for the current waypoint ###
            action = ctrl.computeControlFromState(control_timestep=CTRL_EVERY_N_STEPS*env.TIMESTEP,
                                                  state=state,
                                                  target_pos=TARGET_POS[wp_counter])

            ### Select next waypoint ###
            wp_counter += 1 if wp_counter < NUM_WAY_POINTS-1 else 0
        
        ### Sync the simulation ###
        if gui:
            sync(i, START, env.TIMESTEP)
env.close()